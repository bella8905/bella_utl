#pragma  once 

#define GLM_FORCE_RADIANS
#include "glm/glm.hpp"
#include "glm/gtc/type_ptr.hpp"
#include "glm/gtx/quaternion.hpp"
#include "glm/gtx/transform.hpp"

#include "Utl_Global.h"


/////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////
//
// global variables
//
/////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////
extern const float g_Pi;
extern const float g_Pi2o;
extern const float g_o2Pi;


/////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////
//
// angle conversion
//
/////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////

// radian to degree
extern float RadToDeg( const float& t_rad );
// degree to radian
extern float DegToRad( const float& t_deg );



template<typename T>
bool Equals( const T& t_x, const T& t_y )
{
    return std::abs( t_x - t_y ) < std::numeric_limits<T>::epsilon();
}

// template bool Equals( const float& t_x, const float& t_y );
// template bool Equals( const double& t_x, const double& t_y );

/////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////
//
// vectors and points 
//
/////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////

extern glm::vec3 ToVec3( const glm::vec4& t_v );
extern glm::vec4 ToPositon( const glm::vec3& t_v );
extern glm::vec4 ToDirection( const glm::vec3& t_v );
extern bool SamePoints( const glm::vec3& t_p1, const glm::vec3& t_p2 );
extern bool AreParallel( const glm::vec4& t_v1, const glm::vec4& t_v2 );
extern bool ArePerpendicular( const glm::vec4& t_v1, const glm::vec4& t_v2 );
extern bool IsPosition( const glm::vec4& t_v );
extern bool IsDirection( const glm::vec4& t_v );

/////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////
//
// matrix 
//
/////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////
extern glm::mat4 Matrix_ToMat4( const glm::mat3& t_mat );
extern glm::mat3 Matrix_ToMat3( const glm::mat4& t_mat );

/////////////////////////////////////////////////////////////////
//
// get transform matrix from translate, rotate and scale
//
/////////////////////////////////////////////////////////////////
extern glm::mat4 Matrix_GetTransformMatrixFromTranslateRotateScale( const glm::vec3& t_Trans, const glm::vec3& t_Rotat, const glm::vec3& t_Scale );

/////////////////////////////////////////////////////////////////
// belows are only for affine transformations
/////////////////////////////////////////////////////////////////
//
// get translation from transform matrix
//
/////////////////////////////////////////////////////////////////
extern void Matrix_GetTranslation( const glm::mat4& t_transform, glm::vec3& t_out );
extern void Matrix_GetTranslation( const glm::mat4& t_transform, glm::mat4& t_out );

/////////////////////////////////////////////////////////////////
//
// get rotation from transform matrix
//
/////////////////////////////////////////////////////////////////
extern void Matrix_GetRotation( const glm::mat4& t_transform, glm::mat3& t_out );
extern void Matrix_GetRotation( const glm::mat4& t_transform, glm::mat4& t_out );

/////////////////////////////////////////////////////////////////
//
// get scale from transform matrix
//
/////////////////////////////////////////////////////////////////
extern void Matrix_GetScale( const glm::mat4& t_transform, glm::vec3& t_out );
extern void Matrix_GetScale( const glm::mat4& t_transform, glm::mat4& t_out );

/////////////////////////////////////////////////////////////////
//
// get inverse matrix for an transformation,
// which only contains rotation and translation.
// this is the most common matrix we see for our engine.
//
/////////////////////////////////////////////////////////////////
extern glm::mat4 Matrix_GetInverseTranslationRotation( const glm::mat4& t_transform );

/////////////////////////////////////////////////////////////////
//
// is matrix orthonormal
//
/////////////////////////////////////////////////////////////////
extern bool Matrix_IsOrthonormal( const glm::mat4& t_m, float t_engthThreshold = 0.001, float t_cosineThreshold = 0.005 );



/////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////
//
// Ray and Intersection 
//
/////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////
struct SRay
{
    glm::vec4 _Origin;
    glm::vec4 _Dir;  // normalized direction vector

    SRay()
    {
    }
    SRay( const glm::vec4& t_Origin, const glm::vec4& t_Dir ) : _Origin( t_Origin ), _Dir( glm::normalize( t_Dir ) )
    {
    }
    SRay( const glm::vec3& t_Origin, const glm::vec3& t_Dir ) : _Origin( t_Origin, 1.f ), _Dir( glm::normalize( t_Dir ), 0.f )
    {
    }

    glm::vec4 GetPointOnRay( const float& t_Scale ) const
    {
        return _Origin + t_Scale * _Dir;
    }
    SRay Transform( const glm::mat4& t_TransMat ) const
    {
        return SRay( t_TransMat * _Origin, t_TransMat * _Dir );
    }
    SRay Translate( const glm::vec3& t_offset ) const
    {
        return SRay( glm::vec4( t_offset, 0.f ) + _Origin, _Dir );
    }
    SRay GetRefletedRay( const glm::vec4& t_InstPoint, const glm::vec4& t_SurfaceNormal ) const;

    float RayIntersectTestWithSphere( const glm::vec4& t_center, const float& t_radius );
    float RayIntersectTestWithAxisAlignedBox( const glm::vec3& t_mins, const glm::vec3& t_maxs );
};


/////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////
//
// misc 
//
/////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////
//
// if a value is power of two
//
/////////////////////////////////////////////////////////////////
extern bool IsPOT( int t_val );
